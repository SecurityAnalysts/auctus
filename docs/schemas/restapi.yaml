openapi: 3.0.1
info:
  title: "Auctus"
  description: |
    # Introduction

    Auctus is a dataset search engine and data augmentation platform developed at New York University. It can be used to index the content of datasets from a variety of sources, that can later be queried to find data that can be joined or appended to a user's data.

    The system can be found at this address: https://auctus.vida-nyu.org/

    You can find the source code on GitLab: https://gitlab.com/ViDA-NYU/auctus/auctus

    The rest of the documentation, including the web UI and the Python libraries: https://docs.auctus.vida-nyu.org/

    # REST API introduction

    There is also a [Python client library](https://docs.auctus.vida-nyu.org/python/datamart-rest.html) for this API.

    The API is versioned, with the current version being `v1`. The full paths for an API request would therefore be something like:

        https://auctus.vida-nyu.org/api/v1/download/datamart.socrata.data-cityofnewyork-us.ht4t-wzcm
  contact:
    email: "remi.rampin@nyu.edu"
  license:
    name: "MIT"
  version: "v1"
externalDocs:
  description: "Auctus documentation"
  url: "https://docs.auctus.vida-nyu.org/"
servers:
- url: "https://auctus.vida-nyu.org/api/v1"
tags:
- name: "Query"
  description: "Searching the index for datasets to download or augment with."
- name: "Ingest"
  description: "Adding new datasets to the index."
- name: "Augment"
  description: "Using Auctus to perform server-side augmentation."
paths:
  /upload:
    post:
      tags:
      - "Ingest"
      summary: "Add a dataset to the index"
      description: |
        The file can be provided either via a URL or direct upload of a supported format.

        When providing a URL, make sure it is a direct link to a file in a supported format (CSV, Excel, SPSS, ...) and not to an HTML page with a "download" button or GitHub page where the content is embedded (use the "raw" button).

        The request will return the ID of the new dataset immediately, but profiling will happen in the background so the file will only appear in searches after a couple minutes.
      operationId: "upload"
      requestBody:
        content:
          multipart/form-data:
            schema:
              oneOf:
              - title: URL
                properties:
                  name:
                    type: string
                    description: "Dataset name"
                  description:
                    type: string
                  address:
                    type: string
                required:
                - name
                - address
              - title: direct upload
                properties:
                  name:
                    type: string
                    description: "Dataset name"
                  description:
                    type: string
                  file:
                    type: string
                    format: binary
                required:
                - name
                - file
        required: true
      responses:
        200:
          description: "OK, provides ID of dataset (which will be available once profiling ends)"
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                required:
                - id
                additionalProperties: false
        400:
          description: "Error"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
  /search:
    post:
      tags:
      - "Query"
      summary: "Search the index for datasets"
      description: |
        The `Content-Type` should be set to [`multipart/form-data`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) to allow sending both the query description (JSON) and the data file. Alternatively you can post just JSON or just data.

        You need to specify at least one of `data` (tabular file), `data_profile` (profile information), or `query` (JSON query).
      operationId: "search"
      parameters:
      - in: query
        name: "page"
        schema:
          type: integer
          minimum: 1
        required: false
      - in: query
        name: "size"
        schema:
          type: integer
          minimum: 1
        required: false
      requestBody:
        content:
          multipart/form-data:
            schema:
              properties:
                data:
                  type: string
                  description: "Data which you want to augment"
                  format: binary
                query:
                  $ref: "#/components/schemas/Query"
              # TODO: One of the two needs to be provided
            encoding:
              query:
                contentType: application/json
            examples:
              keyword_search:
                summary: "Search using the keywords 'taxi' and 'medallion'"
                value:
                  query:
                    keywords:
                      - "taxi"
                      - "medallion"
                    variables: []
              geo_bronx:
                summary: "Search for geospatial datasets concerning the Bronx"
                value:
                  query:
                    keywords: []
                    variables:
                    - type: geospatial_variable
                      latitude1: 40.894673917657514
                      latitude2: 40.823526516469315
                      longitude1: -73.91395568847656
                      longitude2: -73.82675170898438
          application/json:
            schema:
              $ref: "#/components/schemas/Query"
            examples:
              keyword_search:
                summary: "Search using the keywords 'taxi' and 'medallion'"
                value:
                  keywords:
                    - "taxi"
                    - "medallion"
                  variables: []
              geo_bronx:
                summary: "Search for geospatial datasets concerning the Bronx"
                value:
                  keywords: []
                  variables:
                  - type: geospatial_variable
                    latitude1: 40.894673917657514
                    latitude2: 40.823526516469315
                    longitude1: -73.91395568847656
                    longitude2: -73.82675170898438
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                properties:
                  results:
                    type: array
                    items:
                      $ref: "#/components/schemas/Result"
                  facets:
                    $ref: "#/components/schemas/Facets"
                required: ["results"]
                additionalProperties: false
        400:
          description: "Invalid query"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
  /profile:
    post:
      tags:
      - "Query"
      summary: Profile a dataset
      description: |
        The JSON object returned by this endpoint can be passed to `/search` as the `data_profile`.

        It replaces the `data` argument, allowing for lighter searches since the data is only sent once. This is useful in situation where the user will incrementally adjust his query.
      operationId: "profile"
      requestBody:
        content:
          multipart/form-data:
            schema:
              properties:
                data:
                  type: string
                  description: Data which you want to profile
                  format: binary
            examples:
              simple:
                summary: Example CSV file
                value:
                  data: "name,country,number,what\nremi,france,4,false\naecio,brazil,3,true\nsonia,peru,7,true\nroque,peru,8,true\nfernando,brazil,10,false\n"
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                type: object  # TODO
        400:
          description: Invalid query
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
  /download/{dataset_id}:
    get:
      tags:
      - "Query"
      summary: "Download a dataset by its ID"
      description: |
        This allows you to retrieve a dataset in CSV or another supported output format.

        You can use the `format` query parameter to specify an output format, for example `/download?format=d3m`:

          * `csv`: returns the dataset as a CSV file (`application/octet-stream`); this is the default option
          * `d3m`: returns a ZIP file (`application/zip`) containing the dataset as a CSV file and its corresponding `datasetDoc.json` file. See [the D3M Dataset Schema documentation](https://gitlab.com/datadrivendiscovery/data-supply/-/blob/shared/documentation/datasetSchema.md) for more information.

        Note that this endpoint might serve data directly or it might redirect to another location.
      operationId: "download_id"
      parameters:
      - in: path
        name: "dataset_id"
        schema:
          type: string
        required: true
        examples:
          nyc_data:
            value: "datamart.socrata.data-cityofnewyork-us.395v-hkhg"
      - in: query
        name: "format"
        schema:
          enum: ["csv", "d3m"]
      responses:
        404:
          description: "No dataset with this ID"
        200:
          description: OK
        302:
          description: "OK, redirects to dataset"
  /download:
    post:
      tags:
      - "Query"
      summary: "Download a dataset from a search result"
      description: |
        This allows you to retrieve a dataset in CSV (or another supported output format using the `format` query parameter, see above).

        Note that this endpoint might serve data directly or it might redirect to another location.

        This endpoint differs from `/download/{dataset_id}` in that it takes a full dataset record instead of just an ID. The advantage is that you can change this record to some extent (example: skip some converters) or send the record for a dataset the server doesn't have in its index (as long as sufficient materialization information is present).
      operationId: "download"
      parameters:
      - in: query
        name: "format"
        schema:
          enum: ["csv", "d3m"]
      requestBody:
        content:
          application/json:
            schema:
                $ref: "#/components/schemas/Result" # TODO: not quite
            examples:
              nyc_data:
                summary: "Sample search result sent back as task"
                value:
                  id: "datamart.socrata.data-cityofnewyork-us.vbgf-ket3"
                  metadata:
                    columns:
                      - name: "Borough"
                      - name: "Calendar Year"
                      - name: "Filed Violation Count"
                    materialize:
                      socrata_id: "vbgf-ket3"
                      socrata_domain: "data.cityofnewyork.us"
                      socrata_updated: "2019-04-29T16:54:13.000Z"
                      direct_url: "https://data.cityofnewyork.us/api/views/vbgf-ket3/rows.csv?accessType=DOWNLOAD"
                      identifier: datamart.socrata
                      date: "2019-06-27T19:26:53.147559Z"
          multipart/form-data:
            schema:
              properties:
                task:
                  $ref: "#/components/schemas/Result" # TODO: not quite
              required:
              - task
            examples:
              nyc_data:
                summary: "Sample search result sent back as task"
                value:
                  task:
                    id: "datamart.socrata.data-cityofnewyork-us.vbgf-ket3"
                    metadata:
                      columns:
                        - name: "Borough"
                        - name: "Calendar Year"
                        - name: "Filed Violation Count"
                      materialize:
                        socrata_id: "vbgf-ket3"
                        socrata_domain: "data.cityofnewyork.us"
                        socrata_updated: "2019-04-29T16:54:13.000Z"
                        direct_url: "https://data.cityofnewyork.us/api/views/vbgf-ket3/rows.csv?accessType=DOWNLOAD"
                        identifier: datamart.socrata
                        date: "2019-06-27T19:26:53.147559Z"
            encoding:
              task:
                contentType: application/json
      responses:
        404:
          description: "No dataset for this result"
        200:
          description: OK
        400:
          description: "Invalid query"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
  /augment:
    post:
      tags:
      - "Augment"
      summary: "Augment an input dataset with a selected search result"
      description: |
        The `Content-Type` should be set to [`multipart/form-data`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) to allow sending both a dataset search result (`task`) and a data file (`data`).
      operationId: "augment"
      requestBody:
        content:
          multipart/form-data:
            schema:
              properties:
                data:
                  type: string
                  description: "Data which you want to augment"
                  format: binary
                task:
                  $ref: "#/components/schemas/Result"
              required:
              - task
            encoding:
              task:
                contentType: application/json
      responses:
        200:
          description: OK
        400:
          description: "Invalid request"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
components:
  schemas:
    Query:
      $ref: "query_input_schema.json"
    Error:
      description: "JSON object returned by API on client errors"
      properties:
        error:
          type: string
          description: "The error message"
    Result:
      $ref: "query_result_schema.json"
    Facets:
      additionalProperties:
        properties:
          buckets:
            additionalProperties:
              type: integer
          incomplete:
            type: boolean
